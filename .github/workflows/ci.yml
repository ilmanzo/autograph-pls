name: autograph-pls CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

# Optional: Repository permissions for publishing coverage badges
permissions:
  contents: read
  pages: write
  id-token: write
  pull-requests: write # For commenting on PRs with coverage info

env:
  GO_VERSION: "1.24"

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Check Go module
        run: |
          if [ ! -f go.mod ]; then
            echo "go.mod not found, initializing..."
            go mod init github.com/autograph-pls || true
          fi
          echo "go.mod exists:"
          cat go.mod

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-modules
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-

      - name: Download dependencies
        run: go mod download

      - name: Verify dependencies
        run: go mod verify

      - name: Run go vet
        run: go vet ./...

      - name: Run go fmt check
        run: |
          if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
            echo "Code is not formatted properly:"
            gofmt -s -l .
            exit 1
          fi
        shell: bash

      - name: Build binary
        run: go build -o autograph-pls

      - name: Run unit tests
        run: go test -v -race -coverprofile=coverage.out ./...

      - name: Generate coverage report
        run: |
          go tool cover -html=coverage.out -o coverage.html
          go tool cover -func=coverage.out -o coverage.txt

          # Extract total coverage percentage
          total_coverage=$(grep -E 'total:.*statements' coverage.txt | sed -E 's/.*statements\s+([0-9.]+)%.*/\1/')
          echo "COVERAGE_PCT=$total_coverage" >> $GITHUB_ENV

          # Check if coverage meets threshold
          coverage_threshold=70.0
          if (( $(echo "$total_coverage < $coverage_threshold" | bc -l) )); then
            echo "::warning::Code coverage is below threshold! Current: ${total_coverage}%, Required: ${coverage_threshold}%"
            echo "coverage_status=‚ö†Ô∏è Below Threshold" >> $GITHUB_ENV
          else
            echo "coverage_status=‚úÖ Passed" >> $GITHUB_ENV
          fi

          # Create coverage badge JSON
          mkdir -p coverage-badge
          cat > coverage-badge/coverage.json << EOF
          {
            "schemaVersion": 1,
            "label": "coverage",
            "message": "${total_coverage}%",
            "color": $(if (( $(echo "$total_coverage >= 80" | bc -l) )); then echo '"brightgreen"'; elif (( $(echo "$total_coverage >= $coverage_threshold" | bc -l) )); then echo '"yellow"'; else echo '"red"'; fi)
          }
          EOF

          # Save threshold for other jobs
          echo "COVERAGE_THRESHOLD=$coverage_threshold" >> $GITHUB_ENV

      - name: Create Coverage Summary
        run: |
          echo "## üìä Code Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Status | Coverage | Threshold |" >> $GITHUB_STEP_SUMMARY
          echo "| :----: | :------: | :-------: |" >> $GITHUB_STEP_SUMMARY
          echo "| ${{ env.coverage_status }} | ${{ env.COVERAGE_PCT }}% | 70.0% |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Detailed Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat coverage.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage.out
            coverage.html
            coverage.txt
            coverage-badge/

      - name: Check minimum coverage
        run: |
          # Compare with threshold and fail if below
          if (( $(echo "${{ env.COVERAGE_PCT }} < ${{ env.COVERAGE_THRESHOLD }}" | bc -l) )); then
            echo "::error::Code coverage is below threshold! Current: ${{ env.COVERAGE_PCT }}%, Required: ${{ env.COVERAGE_THRESHOLD }}%"
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              # Only fail on PRs to enforce coverage on new code
              exit 1
            fi
          fi

      - name: Upload coverage badge
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge
          path: coverage-badge/

      - name: Test algorithm listing
        run: ./autograph-pls -list

      - name: Test help output
        run: ./autograph-pls -help

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Check Go module
        run: |
          if [ ! -f go.mod ]; then
            echo "go.mod not found, initializing..."
            go mod init github.com/autograph-pls || true
          fi
          echo "go.mod exists:"
          cat go.mod

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-modules
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-

      - name: Build binary
        run: go build -o autograph-pls

      - name: Create test results directory
        run: mkdir -p test-results

      - name: Test good files (should succeed)
        run: |
          echo "Testing good signature files..."
          success_count=0
          total_count=0

          for file in testfiles/good/*; do
            if [ -f "$file" ]; then
              echo "Testing $file..."
              total_count=$((total_count + 1))

              if timeout 30 ./autograph-pls "$file" > "test-results/$(basename "$file").log" 2>&1; then
                echo "‚úÖ SUCCESS: $file"
                success_count=$((success_count + 1))
              else
                echo "‚ùå FAILED: $file"
                echo "Output:"
                cat "test-results/$(basename "$file").log"
              fi
            fi
          done

          echo "Good files test summary: $success_count/$total_count succeeded"
          echo "good_files_success=$success_count" >> $GITHUB_ENV
          echo "good_files_total=$total_count" >> $GITHUB_ENV

          if [ $success_count -ne $total_count ]; then
            echo "‚ùå Not all good files passed!"
            exit 1
          fi

      - name: Test bad files (should fail gracefully)
        run: |
          echo "Testing bad/malformed signature files..."
          graceful_failures=0
          total_count=0

          for file in testfiles/bad/*; do
            if [ -f "$file" ]; then
              echo "Testing $file..."
              total_count=$((total_count + 1))

              # Run with timeout and capture exit code
              if timeout 30 ./autograph-pls "$file" > "test-results/$(basename "$file").log" 2>&1; then
                # Check if it failed gracefully (exit code 1) or found no signature
                if grep -q "no valid signature found\|Error:" "test-results/$(basename "$file").log"; then
                  echo "‚úÖ GRACEFUL FAILURE: $file"
                  graceful_failures=$((graceful_failures + 1))
                else
                  echo "‚ö†Ô∏è UNEXPECTED SUCCESS: $file (bad file that should fail)"
                  echo "Output:"
                  cat "test-results/$(basename "$file").log"
                fi
              else
                exit_code=$?
                if [ $exit_code -eq 1 ]; then
                  echo "‚úÖ GRACEFUL FAILURE: $file"
                  graceful_failures=$((graceful_failures + 1))
                elif [ $exit_code -eq 124 ]; then
                  echo "‚ùå TIMEOUT: $file"
                  echo "Program did not complete within 30 seconds"
                else
                  echo "‚ùå CRASH: $file (exit code: $exit_code)"
                  echo "Output:"
                  cat "test-results/$(basename "$file").log"
                  exit 1
                fi
              fi
            fi
          done

          echo "Bad files test summary: $graceful_failures/$total_count failed gracefully"
          echo "bad_files_graceful=$graceful_failures" >> $GITHUB_ENV
          echo "bad_files_total=$total_count" >> $GITHUB_ENV

      - name: Test signature extraction
        run: |
          echo "Testing signature extraction functionality..."
          test_file="testfiles/good/bootx64.efi"

          if [ -f "$test_file" ]; then
            # Test without -s flag (should not create file)
            ./autograph-pls "$test_file" > test-results/extraction-test.log 2>&1
            if [ -f "signature.der" ]; then
              echo "‚ùå FAILED: signature.der created without -s flag"
              exit 1
            else
              echo "‚úÖ SUCCESS: No file created without -s flag"
            fi

            # Test with -s flag (should create file)
            ./autograph-pls -s "$test_file" > test-results/extraction-with-flag.log 2>&1
            if [ -f "signature.der" ]; then
              echo "‚úÖ SUCCESS: signature.der created with -s flag"
              echo "File size: $(stat -f%z signature.der 2>/dev/null || stat -c%s signature.der)"
              rm signature.der
            else
              echo "‚ùå FAILED: signature.der not created with -s flag"
              exit 1
            fi

            # Test with custom output file
            ./autograph-pls -s -o custom.der "$test_file" > test-results/extraction-custom.log 2>&1
            if [ -f "custom.der" ]; then
              echo "‚úÖ SUCCESS: custom.der created"
              rm custom.der
            else
              echo "‚ùå FAILED: custom.der not created"
              exit 1
            fi
          else
            echo "‚ùå Test file $test_file not found"
            exit 1
          fi

      - name: Performance test
        run: |
          echo "Running performance tests..."
          test_file="testfiles/good/bootx64.efi"

          if [ -f "$test_file" ]; then
            echo "Testing parsing speed..."
            time_output=$(time -p ./autograph-pls "$test_file" 2>&1 | grep real || echo "real 0.0")
            echo "Parse time: $time_output"

            echo "Testing with multiple iterations..."
            for i in {1..5}; do
              echo "Iteration $i:"
              timeout 10 ./autograph-pls "$test_file" > /dev/null 2>&1
              if [ $? -eq 124 ]; then
                echo "‚ùå Performance issue: timeout on iteration $i"
                exit 1
              fi
            done
            echo "‚úÖ Performance test passed"
          fi

      - name: Memory safety test
        run: |
          echo "Testing memory safety with large/complex files..."

          # Test all good files for memory safety
          for file in testfiles/good/*; do
            if [ -f "$file" ]; then
              echo "Memory test: $(basename "$file")"
              timeout 60 ./autograph-pls "$file" > /dev/null 2>&1
              case $? in
                0) echo "‚úÖ Memory safe: $file" ;;
                1) echo "‚úÖ Expected failure: $file" ;;
                124) echo "‚ùå Memory issue (timeout): $file"; exit 1 ;;
                *) echo "‚ùå Memory issue (crash): $file"; exit 1 ;;
              esac
            fi
          done

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: integration-test-results
          path: test-results/

      - name: Create test summary
        if: always()
        run: |
          echo "## üß™ Integration Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Good Files (Should Succeed)" >> $GITHUB_STEP_SUMMARY
          echo "- **Success Rate**: ${{ env.good_files_success }}/${{ env.good_files_total }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Bad Files (Should Fail Gracefully)" >> $GITHUB_STEP_SUMMARY
          echo "- **Graceful Failures**: ${{ env.bad_files_graceful }}/${{ env.bad_files_total }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Status" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Build**: Successful" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Unit Tests**: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Code Coverage**: See Test Suite job" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Integration Tests**: Completed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Memory Safety**: Verified" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Performance**: Within limits" >> $GITHUB_STEP_SUMMARY

  coverage-report:
    name: Coverage Report
    runs-on: ubuntu-latest
    needs: test
    if: success() || failure()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: coverage-data

      - name: Process coverage data
        run: |
          cd coverage-data
          if [ ! -f coverage.txt ]; then
            echo "No coverage data found. Test job may have failed."
            echo "## ‚ùå No Coverage Data Available" > ../coverage-summary.md
            exit 0
          fi

          # Parse coverage percentage
          total_coverage=$(grep -E 'total:.*statements' coverage.txt | sed -E 's/.*statements\s+([0-9.]+)%.*/\1/')
          echo "Total coverage: ${total_coverage}%"

          # Generate coverage report summary
          echo "## üìä Detailed Coverage Report" > coverage-summary.md
          echo "" >> coverage-summary.md
          echo "| Package | Statements | Coverage |" >> coverage-summary.md
          echo "| ------- | ---------- | -------- |" >> coverage-summary.md

          # Extract package coverage from coverage.txt
          grep -v "total:" coverage.txt | grep -v "^ok" | while read -r line; do
            package=$(echo "$line" | awk '{print $1}')
            statements=$(echo "$line" | awk '{print $(NF-2)}')
            coverage=$(echo "$line" | awk '{print $NF}' | sed 's/%//')

            # Determine color based on coverage
            if (( $(echo "$coverage >= 80" | bc -l) )); then
              color="green"
            elif (( $(echo "$coverage >= 70" | bc -l) )); then
              color="yellow"
            else
              color="red"
            fi

            echo "| $package | $statements | <span style=\"color:$color\">$coverage%</span> |" >> coverage-summary.md
          done

          # Add total coverage at the end
          echo "| **Total** | | **${total_coverage}%** |" >> coverage-summary.md

          # Save as artifact
          mv coverage-summary.md ..

      - name: Upload coverage summary
        uses: actions/upload-artifact@v4
        with:
          name: coverage-summary
          path: coverage-summary.md

      - name: Publish coverage summary
        run: |
          cat coverage-summary.md >> $GITHUB_STEP_SUMMARY

      # Uncomment to use Codecov (requires CODECOV_TOKEN secret)
      # - name: Upload to Codecov
      #   uses: codecov/codecov-action@v4
      #   with:
      #     files: ./coverage-data/coverage.out
      #     fail_ci_if_error: false
      #     verbose: true
      #     token: ${{ secrets.CODECOV_TOKEN }} # Optional: for private repos

      # Optional: Comment on PR with coverage changes
      # - name: Comment on PR with coverage
      #   if: github.event_name == 'pull_request'
      #   uses: marocchino/sticky-pull-request-comment@v2
      #   with:
      #     path: coverage-summary.md

  release-test:
    name: Release Build Test
    runs-on: ubuntu-latest
    needs: [test, integration-test, coverage-report]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Check Go module
        run: |
          if [ ! -f go.mod ]; then
            echo "go.mod not found, initializing..."
            go mod init github.com/autograph-pls || true
          fi
          echo "go.mod exists:"
          cat go.mod

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ env.GO_VERSION }}-modules
          restore-keys: |
            ${{ runner.os }}-go-${{ env.GO_VERSION }}-

      - name: Build release binaries
        run: |
          # Build for multiple platforms
          GOOS=linux GOARCH=amd64 go build -ldflags="-w -s" -o autograph-pls-linux-amd64
          GOOS=linux GOARCH=arm64 go build -ldflags="-w -s" -o autograph-pls-linux-arm64
          GOOS=linux GOARCH=s390x go build -ldflags="-w -s" -o autograph-pls-linux-s390x
          GOOS=linux GOARCH=ppc64le go build -ldflags="-w -s" -o autograph-pls-linux-ppc64le

          # Test that binaries work
          ./autograph-pls-linux-amd64 -list > /dev/null
          echo "‚úÖ Linux AMD64 binary works"

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-binaries
          path: autograph-pls-*
